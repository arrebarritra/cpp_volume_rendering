#version 430

layout (binding = 1) uniform sampler3D TexVolume;
layout (binding = 2) uniform sampler3D TexVolumeGradient;

uniform vec3 VolumeGridResolution;
uniform vec3 VolumeVoxelSize;
uniform vec3 VolumeGridSize;

uniform vec3 CameraEye;

uniform mat4 u_CameraLookAt;
uniform mat4 ProjectionMatrix;

uniform float u_TanCameraFovY;
uniform float u_CameraAspectRatio;

uniform float Isovalue;
uniform vec4 Color;

uniform bool ApplyGradientPhongShading;

uniform float BlinnPhongKa;
uniform float BlinnPhongKd;
uniform float BlinnPhongKs;
uniform float BlinnPhongShininess;

uniform vec3 BlinnPhongIspecular;

uniform vec3 WorldEyePos;
uniform vec3 LightSourcePosition;

uniform float SearchStepSize = 0.5;
uniform int MaxTraversalLevel;

// kd tree info
uniform int k;
uniform vec3 virtualratio;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba16f, binding = 0) uniform image2D OutputFrag;

//////////////////////////////////////////////////////////////////////////////////////////////////
// From structured/rtisoikd/kd_tree.comp
struct Node { float isoMin, isoMax; };
layout(std430, binding = 3) buffer implKdTree {	Node node[]; };
layout(std430, binding = 4) buffer matrix_S { uvec4 S[]; };
layout(std430, binding = 5) buffer offsets { uint offset[]; };
uint indexToLoc(uint offset, uvec3 U, uvec3 Rl);
//////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////
// From structured/_common_shaders/ray_bbox_intersection.comp
struct Ray { vec3 Origin; vec3 Dir; };
bool IntersectBox (Ray r, vec3 boxmin, vec3 boxmax, out float rtnear, out float rtfar);
bool RayAABBIntersection (vec3 vert_eye, vec3 vert_dir, vec3 vol_scaled_dim,
                          out Ray r, out float rtnear, out float rtfar);
//////////////////////////////////////////////////////////////////////////////////////////////////

vec3 ShadeBlinnPhong (vec3 Tpos, vec3 clr)
{
  // Gradient normal
  vec3 gradient_normal =  texture(TexVolumeGradient, Tpos / VolumeGridSize).xyz;
  
  // If is non-zero
  if (gradient_normal != vec3(0, 0, 0))
  {
    vec3 Wpos = Tpos - (VolumeGridSize * 0.5);
    
    vec3 light_direction = normalize(LightSourcePosition - Wpos);
    vec3 eye_direction   = normalize(CameraEye - Wpos);
    vec3 halfway_vector  = normalize(eye_direction + light_direction);
  
    gradient_normal      = normalize(gradient_normal);
    // We consider front and back faces as the same
    // float FrontOrBack = dot(gradient_normal, eye_direction);
    // if (FrontOrBack < 0)
    // {
    //   gradient_normal = -gradient_normal;
    // }
    
    // float dot_diff = dot(gradient_normal, light_direction);
    // if (dot_diff < 0) dot_diff = dot(-gradient_normal, light_direction);
    float dot_diff = max(0, dot(gradient_normal, light_direction));

    // float dot_spec = dot(halfway_vector, gradient_normal);
    // if (dot_spec < 0) dot_spec = dot(halfway_vector, -gradient_normal);
    float dot_spec = max(0, dot(halfway_vector, gradient_normal));
   
    clr = 
      // rgb only affects ambient + diffuse
      (clr * (BlinnPhongKa + BlinnPhongKd * dot_diff)) 
      // specular contribution has it's own color
      + BlinnPhongIspecular * BlinnPhongKs * pow(dot_spec, BlinnPhongShininess)
    ;
  }

  return clr;
}

bool InterpolateIsovalue(Ray r, inout float tnear, float tfar, out vec3 tex_pos) {    
  vec3 wld_pos = r.Origin + r.Dir * tnear;
  tex_pos = wld_pos + VolumeGridSize * 0.5;
  vec3 vgs_inv = vec3(1.0) / VolumeGridSize;

  float prevDensity = texture(TexVolume, tex_pos * vgs_inv).r ;
  while (tnear < tfar) {
    // Get the current step or the remaining interval
    float h = min(SearchStepSize, tfar - tnear);
    
    // Texture pos at next search step
    tnear += h;
    tex_pos += r.Dir * h;
    
    // Get normalized density from volume
    float density = texture(TexVolume, tex_pos * vgs_inv).r;
    
    // First hit: isosurface
    if ( (prevDensity <= Isovalue && Isovalue <= density)
      || (prevDensity >= Isovalue && Isovalue >= density) )
      return true;
    
    prevDensity = density;
  }

  return false;
}

bool UpdateSearchInterval(Ray r, uvec3 index, uvec3 Vl, out float rtnear, out float rtfar) {
  vec3 nodesize = VolumeGridSize / (Vl * virtualratio);
  vec3 boxmin = -VolumeGridSize * 0.5 + vec3(index) * nodesize;
  vec3 boxmax = min(boxmin + nodesize, VolumeGridSize * 0.5);
  return IntersectBox(r, boxmin, boxmax, rtnear, rtfar);
}

void main ()
{
  ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(OutputFrag);

  if (storePos.x < size.x && storePos.y < size.y)
  {
    // Get screen position [x, y] and consider centering the pixel by + 0.5
    vec2 fpos = vec2(storePos) + 0.5;

    // Transform fpos from [w, h] to [0, 1] to [-1, 1]
    vec3 VerPos = (vec3(fpos.x / float(size.x), fpos.y / float(size.y), 0.0) * 2.0) - 1.0;

    // Camera direction
    vec3 camera_dir = normalize(vec3(VerPos.x * u_TanCameraFovY * u_CameraAspectRatio, VerPos.y * u_TanCameraFovY, -1.0) * mat3(u_CameraLookAt));
    
    // Find Ray Intersection
    Ray r; float tnear, tfar;
    bool inbox = RayAABBIntersection(CameraEye, camera_dir, VolumeGridSize, r, tnear, tfar);

    // If inside volume grid
    if(inbox)
    {
      // Initialize Transparency and Radiance color
      vec4 dst = vec4(0.0);

      // traversal variables
      uvec3 curr_index = uvec3(0, 0, 0);
      uvec3 curr_R = uvec3(1, 1, 1);
      uvec3 curr_V = uvec3(1, 1, 1);
      uint curr_loc = 0u;
      uint level = 0u;
      uint DepthFlags = 0u;
      int a = 0;
      float t_d;
      const vec3 invR = 1.0 / r.Dir;

      // traverse kd tree
      while (true) {
        // determine whether to continue on branch, return to parent or end traversal
        bool return_to_parent = true;
        
        if (Isovalue >= node[curr_loc].isoMin && Isovalue <= node[curr_loc].isoMax && curr_index[a] < curr_R[a]) {
          if (level >= MaxTraversalLevel) {
            // check if isovalue is contained in voxel
            vec3 tex_pos;
            bool exit = false;
            while (InterpolateIsovalue(r, tnear, tfar, tex_pos)) {
              vec4 src = Color;
              // Front-to-back composition
              src.rgb = src.rgb * src.a;

              if (ApplyGradientPhongShading)
                src.rgb = ShadeBlinnPhong(tex_pos, src.rgb);

              dst = dst + (1.0 - dst.a) * src;

              // Exit if at voxel level or opacity threshold is reached
              if (level == k - 1 || dst.a > 0.99) {
                if (dst.a > 0.99) exit = true;
                break;
              }
            }
            if (exit) break;
          } else {
            // continue on branch if it potentially contains isovalue
            return_to_parent = false;
          }
        }

        if (return_to_parent) {
          // attempt to return to parent
          if (DepthFlags > 0u){
            // return to parent using depth flag
            uint returnDepth = findMSB(DepthFlags);
            uvec3 N = (S[level] - S[returnDepth]).xyz;
            curr_index >>= N;
            curr_V >>= N;
            curr_R = uvec3(ceil(virtualratio * curr_V));
            level = returnDepth;
            UpdateSearchInterval(r, curr_index, curr_V, tnear, tfar);
          } else {
            break;
          }
        }

        // determine split plane
        a = int(dot((S[level + 1] - S[level]).xyz, uvec3(0, 1, 2)));
        uint NearFirst = uint(r.Dir[a] >= 0.0);

        // find intersection parameter t_d
        float split_coord = ((curr_index[a] + 0.5) / (curr_V[a] * virtualratio[a]) - 0.5) * VolumeGridSize[a];
        if(abs(r.Dir[a]) > 0.0) {
          t_d = invR[a] * (split_coord - r.Origin[a]);
        } else {
          // if ray is parallel to plane, determine which side of plane it is on
          t_d = r.Origin[a] > split_coord ? tnear : tfar;
        }

        // traverse near, far or both nodes
        // determine index of next node to traverse
        curr_index[a] *= 2;
        if (return_to_parent) {
          // depth flag is set -> reset flag
          DepthFlags &= ~(1u << level);
          curr_index[a] += NearFirst;
          // clip ray to far box bounds
          tnear = t_d;
        } else if (t_d <= tnear) {
          curr_index[a] += NearFirst; // far
        } else if (t_d >= tfar) {
          curr_index[a] += 1u - NearFirst; // near
        } else {
          // depth flag is not set -> set flag
          DepthFlags |= 1u << level;
          curr_index[a] += 1u - NearFirst;
          // clip ray to near box bounds
          tfar = t_d;
        }

        // calculate parameters for node in next level
        curr_V[a] *= 2;
        curr_R = uvec3(ceil(virtualratio * curr_V));
        curr_loc = indexToLoc(offset[++level], curr_index, curr_R);
      }

      imageStore(OutputFrag, storePos, dst);
    }
  }
}
